<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Self-Healing System</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
    <style>
        .status-badge {
            width: 10px;
            height: 10px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-good { background-color: #28a745; }
        .status-warning { background-color: #ffc107; }
        .status-critical { background-color: #dc3545; }
        
        .event-log {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-entry {
            border-left: 4px solid #ccc;
            margin-bottom: 8px;
            padding: 6px 10px;
        }
        
        .log-info { border-left-color: #0d6efd; }
        .log-warning { border-left-color: #ffc107; }
        .log-error { border-left-color: #dc3545; }
        
        .resolved-issue {
            border-left: 4px solid #28a745;
            padding: 8px 15px;
            margin-bottom: 12px;
            background-color: #f8f9fa;
        }
        
        .dashboard-header {
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .dashboard-card {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            margin-bottom: 20px;
        }
        
        .overview-pill {
            font-size: 0.85rem;
            margin-right: 15px;
        }
        
        #socket-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .socket-connected {
            background-color: #28a745;
            color: white;
        }
        
        .socket-disconnected {
            background-color: #dc3545;
            color: white;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">Network Self-Healing System</a>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="dashboard-header">
            <h2>System Dashboard</h2>
            <div class="d-flex mt-3">
                <div class="overview-pill">
                    <span id="status-indicator" class="status-badge status-good"></span>
                    <span id="status-text">Network Status: Good</span>
                </div>
                <div class="overview-pill">
                    <strong>Active Issues:</strong> <span id="active-issues-count">0</span>
                </div>
                <div class="overview-pill">
                    <strong>Resolved Issues:</strong> <span id="resolved-issues-count">0</span>
                </div>
                <div class="overview-pill">
                    <strong>Last Updated:</strong> <span id="last-updated">-</span>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Active Issues Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header d-flex justify-content-between align-items-center bg-white">
                        <h5 class="mb-0">Active Issues</h5>
                        <button id="refreshIssues" class="btn btn-sm btn-outline-primary">Refresh</button>
                    </div>
                    <div class="card-body">
                        <div id="issuesList">
                            <!-- Issues will be loaded here -->
                            <div class="alert alert-info">No active issues detected.</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Network Devices Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header d-flex justify-content-between align-items-center bg-white">
                        <h5 class="mb-0">Network Devices</h5>
                        <button id="refreshDevices" class="btn btn-sm btn-outline-primary">Refresh</button>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>Device</th>
                                        <th>IP Address</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="devicesList">
                                    <!-- Devices will be loaded here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row">
            <!-- Resolved Issues Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">Resolved Issues</h5>
                    </div>
                    <div class="card-body">
                        <div id="resolvedIssuesList" class="resolved-issues-list">
                            <!-- Resolved issues will be loaded here -->
                            <div class="text-center text-muted py-3">No resolved issues yet.</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- System Logs Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">System Logs</h5>
                    </div>
                    <div class="card-body">
                        <div id="systemLogs" class="event-log">
                            <!-- Logs will be loaded here -->
                            <div class="text-center text-muted py-3">No logs available.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Socket.IO connection status indicator -->
    <div id="socket-status" class="socket-disconnected">Disconnected</div>

    <!-- Include Socket.IO client library -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Initialize Socket.IO connection with improved connection options
        const socket = io({
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000,
            // Force new connection to avoid reusing potentially problematic connections
            forceNew: true
        });
        
        // Socket status indicator element
        const socketStatus = document.getElementById('socket-status');
        
        // Socket.IO event handlers
        socket.on('connect', function() {
            console.log('Connected to server via Socket.IO');
            socketStatus.className = 'socket-connected';
            socketStatus.textContent = 'Connected';
            
            // Immediately request data updates
            console.log('Requesting initial data after connection');
            // Fetch all data on reconnection
            loadIssues();
            loadResolvedIssues();
            loadSystemLogs();
            checkNetworkStatus();
        });
        
        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = 'Disconnected';
        });
        
        socket.on('connect_error', function(error) {
            console.error('Connection error:', error);
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = 'Connection Error';
        });
        
        socket.on('reconnect_attempt', function(attemptNumber) {
            console.log(`Reconnection attempt #${attemptNumber}`);
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = `Reconnecting (#${attemptNumber})`;
        });
        
        socket.on('reconnect', function(attemptNumber) {
            console.log(`Reconnected after ${attemptNumber} attempts`);
            socketStatus.className = 'socket-connected';
            socketStatus.textContent = 'Connected';
            
            // Request fresh data after reconnection
            console.log('Requesting data refresh after reconnection');
            socket.emit('request_data_refresh');
        });
        
        // Handle real-time active issues updates
        socket.on('active_issues_update', function(issues) {
            console.log('Received active issues update:', issues);
            
            const issuesList = document.getElementById('issuesList');
            
            if (!issues || issues.length === 0) {
                issuesList.innerHTML = '<div class="alert alert-info">No active issues detected.</div>';
                updateActiveIssuesCount(0);
                return;
            }
            
            issuesList.innerHTML = '';
            issues.forEach(issue => {
                const issueElement = document.createElement('div');
                issueElement.className = 'alert alert-warning';
                issueElement.innerHTML = `
                    <h5>${issue.title}</h5>
                    <p>${issue.description}</p>
                    <div class="d-flex justify-content-between align-items-center">
                        <span class="badge bg-secondary">${issue.status}</span>
                        <small>Detected: ${formatDate(issue.detected_at)}</small>
                        <button class="btn btn-sm btn-primary resolve-issue" data-id="${issue.id}">
                            Resolve
                        </button>
                    </div>
                `;
                issuesList.appendChild(issueElement);
            });
            
            // Add event listeners to resolve buttons
            document.querySelectorAll('.resolve-issue').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    const issueId = this.getAttribute('data-id');
                    console.log("Resolve button clicked with ID:", issueId);
                    resolveIssue(issueId);
                });
            });
            
            // Update stats
            updateActiveIssuesCount(issues.length);
        });
        
        // Handle real-time resolved issues updates
        socket.on('resolved_issues_update', function(history) {
            console.log('Received resolved issues update:', history);
            
            const resolvedList = document.getElementById('resolvedIssuesList');
            
            if (!history || !Array.isArray(history) || history.length === 0) {
                resolvedList.innerHTML = '<div class="text-center text-muted py-3">No resolved issues yet.</div>';
                updateResolvedIssuesCount(0);
                return;
            }
            
            resolvedList.innerHTML = '';
            
            // Sort by most recent first
            history.sort((a, b) => new Date(b.resolved_at || b.detected_at) - new Date(a.resolved_at || a.detected_at));
            
            // Count real resolved issues
            const resolvedCount = history.filter(item => item.resolution_success).length;
            
            // Keep track of how many we actually displayed
            let displayedCount = 0;
            
            // Display only the most recent 10 issues
            history.slice(0, 10).forEach(item => {
                if (!item.resolved_at) {
                    return; // Skip unresolved items
                }
                
                displayedCount++;
                const issueElement = document.createElement('div');
                issueElement.className = 'resolved-issue';
                
                // Format the actions text
                let actionsText = '';
                if (item.resolution_actions && item.resolution_actions.length > 0) {
                    const lastAction = item.resolution_actions[item.resolution_actions.length - 1];
                    actionsText = `<br><small>Strategy: ${lastAction.strategy}</small>`;
                }
                
                issueElement.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <h6 class="mb-1">${getIssueTitle(item.anomaly_type)}</h6>
                        <span class="badge bg-success">Resolved</span>
                    </div>
                    <p class="mb-1 text-muted">
                        <small>Detected: ${formatDate(item.detected_at)}</small>
                        <br>
                        <small>Resolved: ${formatDate(item.resolved_at)}</small>
                        ${actionsText}
                    </p>
                `;
                resolvedList.appendChild(issueElement);
            });
            
            // If we got no displayable items but there are items in history
            if (displayedCount === 0 && history.length > 0) {
                resolvedList.innerHTML = '<div class="alert alert-warning">Found issues in history but none are fully resolved yet.</div>';
            }
            
            // Update stats
            updateResolvedIssuesCount(resolvedCount);
        });
        
        // Handle real-time logs updates
        socket.on('logs_update', function(logs) {
            console.log('Received logs update');
            
            const logsContainer = document.getElementById('systemLogs');
            
            if (!logs || logs.length === 0) {
                logsContainer.innerHTML = '<div class="text-center text-muted py-3">No logs available.</div>';
                return;
            }
            
            logsContainer.innerHTML = '';
            
            // Sort by most recent first
            logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            logs.forEach(log => {
                const logEntry = document.createElement('div');
                let logClass = 'log-info';
                
                if (log.level === 'WARNING') logClass = 'log-warning';
                if (log.level === 'ERROR') logClass = 'log-error';
                
                logEntry.className = `log-entry ${logClass}`;
                logEntry.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <small>${formatDate(log.timestamp)}</small>
                        <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                    </div>
                    <div class="mt-1">
                        <strong>[${log.source}]</strong> ${log.message}
                    </div>
                `;
                logsContainer.appendChild(logEntry);
            });
        });
        
        // Handle individual log entries
        socket.on('log_entry', function(log) {
            console.log('Received new log entry');
            
            const logsContainer = document.getElementById('systemLogs');
            
            // Remove placeholder if it exists
            if (logsContainer.innerHTML.includes('No logs available')) {
                logsContainer.innerHTML = '';
            }
            
            const logEntry = document.createElement('div');
            let logClass = 'log-info';
            
            if (log.level === 'WARNING') logClass = 'log-warning';
            if (log.level === 'ERROR') logClass = 'log-error';
            
            logEntry.className = `log-entry ${logClass}`;
            logEntry.innerHTML = `
                <div class="d-flex justify-content-between">
                    <small>${formatDate(log.timestamp)}</small>
                    <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                </div>
                <div class="mt-1">
                    <strong>[${log.source}]</strong> ${log.message}
                </div>
            `;
            
            // Add at the beginning (most recent first)
            if (logsContainer.firstChild) {
                logsContainer.insertBefore(logEntry, logsContainer.firstChild);
            } else {
                logsContainer.appendChild(logEntry);
            }
            
            // Limit number of logs displayed
            while (logsContainer.children.length > 50) {
                logsContainer.removeChild(logsContainer.lastChild);
            }
        });
        
        // Handle network status updates
        socket.on('network_status_update', function(status) {
            console.log('Received network status update');
            
            // Update dashboard header
            updateDashboardStats(
                document.getElementById('active-issues-count').textContent,
                document.getElementById('resolved-issues-count').textContent,
                status.overall_health
            );
        });
        
        // Handle device updates
        socket.on('devices_update', function(devices) {
            console.log('Received devices update');
            
            const devicesList = document.getElementById('devicesList');
            devicesList.innerHTML = '';
            
            devices.forEach(device => {
                const row = document.createElement('tr');
                let statusClass = device.status === 'up' ? 'success' : 
                                  device.status === 'warning' ? 'warning' : 'danger';
                
                row.innerHTML = `
                    <td>${device.hostname || device.name}</td>
                    <td>${device.ip}</td>
                    <td><span class="badge bg-${statusClass}">${device.status}</span></td>
                `;
                devicesList.appendChild(row);
            });
        });

        // Initialize date formatter
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleString();
        }
        
        // Update the dashboard header with current stats
        function updateDashboardStats(activeCount, resolvedCount, networkStatus) {
            document.getElementById('active-issues-count').textContent = activeCount;
            document.getElementById('resolved-issues-count').textContent = resolvedCount;
            document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
            
            // Update network status indicator
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            statusIndicator.className = 'status-badge';
            if (networkStatus === 'good') {
                statusIndicator.classList.add('status-good');
                statusText.textContent = 'Network Status: Good';
            } else if (networkStatus === 'warning') {
                statusIndicator.classList.add('status-warning');
                statusText.textContent = 'Network Status: Warning';
            } else {
                statusIndicator.classList.add('status-critical');
                statusText.textContent = 'Network Status: Critical';
            }
        }

        // Load devices list
        function loadDevices() {
            fetch('/api/network/devices')
                .then(response => response.json())
                .then(devices => {
                    const devicesList = document.getElementById('devicesList');
                    devicesList.innerHTML = '';
                    
                    devices.forEach(device => {
                        const row = document.createElement('tr');
                        let statusClass = 'success';
                        if (device.status === 'warning') statusClass = 'warning';
                        if (device.status === 'error' || device.status === 'down') statusClass = 'danger';
                        
                        row.innerHTML = `
                            <td>${device.name}</td>
                            <td>${device.ip}</td>
                            <td><span class="badge bg-${statusClass}">${device.status}</span></td>
                        `;
                        devicesList.appendChild(row);
                    });
                })
                .catch(error => console.error('Error loading devices:', error));
        }

        // Load active issues
        function loadIssues() {
            fetch('/api/healing/issues')
                .then(response => response.json())
                .then(issues => {
                    const issuesList = document.getElementById('issuesList');
                    
                    if (issues.length === 0) {
                        issuesList.innerHTML = '<div class="alert alert-info">No active issues detected.</div>';
                        return;
                    }
                    
                    issuesList.innerHTML = '';
                    issues.forEach(issue => {
                        const issueElement = document.createElement('div');
                        issueElement.className = 'alert alert-warning';
                        issueElement.innerHTML = `
                            <h5>${issue.title}</h5>
                            <p>${issue.description}</p>
                            <div class="d-flex justify-content-between align-items-center">
                                <span class="badge bg-secondary">${issue.status}</span>
                                <small>Detected: ${formatDate(issue.detected_at)}</small>
                                <button class="btn btn-sm btn-primary resolve-issue" data-id="${issue.id}">
                                    Resolve
                                </button>
                            </div>
                        `;
                        issuesList.appendChild(issueElement);
                    });
                    
                    // Add event listeners to resolve buttons
                    document.querySelectorAll('.resolve-issue').forEach(button => {
                        // Remove any existing event listeners to prevent duplicates
                        button.replaceWith(button.cloneNode(true));
                        
                        // Get the fresh button
                        const freshButton = issuesList.querySelector(`.resolve-issue[data-id="${button.getAttribute('data-id')}"]`);
                        
                        // Add event listener to the fresh button
                        freshButton.addEventListener('click', function(event) {
                            // Prevent default action
                            event.preventDefault();
                            event.stopPropagation();
                            
                            const issueId = this.getAttribute('data-id');
                            console.log("Resolve button clicked with ID:", issueId);
                            resolveIssue(issueId);
                        });
                    });
                    
                    // Update stats
                    updateActiveIssuesCount(issues.length);
                })
                .catch(error => console.error('Error loading issues:', error));
        }
        
        // Load resolved issues
        function loadResolvedIssues() {
            console.log("Loading resolved issues...");
            fetch('/api/healing/resolved')
                .then(response => {
                    console.log("Resolved issues response:", response.status);
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(history => {
                    console.log("Resolved issues raw data:", JSON.stringify(history).substring(0, 200) + "...");
                    console.log("Resolved issues count:", history ? history.length : 0);
                    
                    const resolvedList = document.getElementById('resolvedIssuesList');
                    
                    if (!history || !Array.isArray(history) || history.length === 0) {
                        resolvedList.innerHTML = '<div class="text-center text-muted py-3">No resolved issues yet.</div>';
                        updateResolvedIssuesCount(0);
                        return;
                    }
                    
                    resolvedList.innerHTML = '';
                    
                    // Sort by most recent first
                    history.sort((a, b) => new Date(b.resolved_at || b.detected_at) - new Date(a.resolved_at || a.detected_at));
                    
                    // Count real resolved issues
                    const resolvedCount = history.filter(item => item.resolution_success).length;
                    console.log(`Displaying ${resolvedCount} resolved issues`);
                    
                    // Keep track of how many we actually displayed
                    let displayedCount = 0;
                    
                    // Display only the most recent 10 issues
                    history.slice(0, 10).forEach(item => {
                        console.log("Processing resolved item:", item);
                        if (!item.resolved_at) {
                            console.log("Skipping unresolved item");
                            return; // Skip unresolved items
                        }
                        
                        displayedCount++;
                        const issueElement = document.createElement('div');
                        issueElement.className = 'resolved-issue';
                        
                        // Format the actions text
                        let actionsText = '';
                        if (item.resolution_actions && item.resolution_actions.length > 0) {
                            const lastAction = item.resolution_actions[item.resolution_actions.length - 1];
                            actionsText = `<br><small>Strategy: ${lastAction.strategy}</small>`;
                        }
                        
                        issueElement.innerHTML = `
                            <div class="d-flex justify-content-between">
                                <h6 class="mb-1">${getIssueTitle(item.anomaly_type)}</h6>
                                <span class="badge bg-success">Resolved</span>
                            </div>
                            <p class="mb-1 text-muted">
                                <small>Detected: ${formatDate(item.detected_at)}</small>
                                <br>
                                <small>Resolved: ${formatDate(item.resolved_at)}</small>
                                ${actionsText}
                            </p>
                        `;
                        resolvedList.appendChild(issueElement);
                    });
                    
                    // If we got no displayable items but there are items in history
                    if (displayedCount === 0 && history.length > 0) {
                        resolvedList.innerHTML = '<div class="alert alert-warning">Found issues in history but none are fully resolved yet.</div>';
                    }
                    
                    // Update stats
                    updateResolvedIssuesCount(resolvedCount);
                })
                .catch(error => {
                    console.error('Error loading resolved issues:', error);
                    document.getElementById('resolvedIssuesList').innerHTML = 
                        '<div class="alert alert-danger">Error loading resolved issues: ' + error.message + '</div>';
                });
        }
        
        // Load system logs
        function loadSystemLogs() {
            fetch('/api/logs')
                .then(response => response.json())
                .then(logs => {
                    const logsContainer = document.getElementById('systemLogs');
                    
                    if (logs.length === 0) {
                        logsContainer.innerHTML = '<div class="text-center text-muted py-3">No logs available.</div>';
                        return;
                    }
                    
                    logsContainer.innerHTML = '';
                    
                    // Sort by most recent first
                    logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    
                    logs.forEach(log => {
                        const logEntry = document.createElement('div');
                        let logClass = 'log-info';
                        
                        if (log.level === 'WARNING') logClass = 'log-warning';
                        if (log.level === 'ERROR') logClass = 'log-error';
                        
                        logEntry.className = `log-entry ${logClass}`;
                        logEntry.innerHTML = `
                            <div class="d-flex justify-content-between">
                                <small>${formatDate(log.timestamp)}</small>
                                <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                            </div>
                            <div class="mt-1">
                                <strong>[${log.source}]</strong> ${log.message}
                            </div>
                        `;
                        logsContainer.appendChild(logEntry);
                    });
                })
                .catch(error => console.error('Error loading logs:', error));
        }

        // Resolve issue
        function resolveIssue(issueId) {
            console.log("Resolve button clicked for issue:", issueId);
            fetch('/api/healing/resolve', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ issue_id: issueId })
            })
            .then(response => {
                console.log("Resolve response status:", response.status);
                return response.json();
            })
            .then(result => {
                console.log("Resolve result:", result);
                if (result.success) {
                    loadIssues();
                    loadResolvedIssues();
                    loadSystemLogs();
                    alert('Issue resolved successfully!');
                } else {
                    alert('Failed to resolve issue: ' + result.message);
                }
            })
            .catch(error => {
                console.error('Error resolving issue:', error);
                alert('Error resolving issue: ' + error.message);
            });
        }
        
        // Helper functions for stats
        function updateActiveIssuesCount(count) {
            document.getElementById('active-issues-count').textContent = count;
        }
        
        function updateResolvedIssuesCount(count) {
            document.getElementById('resolved-issues-count').textContent = count;
        }
        
        // Helper function to get friendly title for issue types
        function getIssueTitle(anomalyType) {
            const titles = {
                'high_latency': 'High Network Latency',
                'packet_loss': 'Packet Loss Issues',
                'dns_resolution_failure': 'DNS Resolution Failure',
                'routing_loop': 'Network Routing Loop',
                'bandwidth_saturation': 'Bandwidth Saturation',
                'connection_timeout': 'Connection Timeout',
                'security_breach': 'Security Breach',
                'device_failure': 'Device Failure',
                'general_anomaly': 'Network Anomaly'
            };
            return titles[anomalyType] || 'Network Issue';
        }
        
        // Check network status
        function checkNetworkStatus() {
            fetch('/api/network/status')
                .then(response => response.json())
                .then(status => {
                    updateDashboardStats(
                        document.getElementById('active-issues-count').textContent,
                        document.getElementById('resolved-issues-count').textContent,
                        status.overall_health
                    );
                })
                .catch(error => console.error('Error checking network status:', error));
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
            loadDevices();
            loadIssues();
            loadResolvedIssues();
            loadSystemLogs();
            checkNetworkStatus();
            
            // Set up refresh buttons
            document.getElementById('refreshDevices').addEventListener('click', loadDevices);
            document.getElementById('refreshIssues').addEventListener('click', loadIssues);
        });
        
        // Add a heartbeat to keep connection alive
        setInterval(function() {
            if (socket.connected) {
                console.log('Sending heartbeat ping');
                socket.emit('ping');
            }
        }, 25000);
    </script>
</body>
</html>