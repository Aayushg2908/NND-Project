<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Self-Healing System</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
    <style>
        .status-badge {
            width: 10px;
            height: 10px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-good { background-color: #28a745; }
        .status-warning { background-color: #ffc107; }
        .status-critical { background-color: #dc3545; }
        
        .event-log {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-entry {
            border-left: 4px solid #ccc;
            margin-bottom: 8px;
            padding: 6px 10px;
        }
        
        .log-info { border-left-color: #0d6efd; }
        .log-warning { border-left-color: #ffc107; }
        .log-error { border-left-color: #dc3545; }
        
        .resolved-issue {
            border-left: 4px solid #28a745;
            padding: 8px 15px;
            margin-bottom: 12px;
            background-color: #f8f9fa;
        }
        
        .dashboard-header {
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .dashboard-card {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            margin-bottom: 20px;
        }
        
        .overview-pill {
            font-size: 0.85rem;
            margin-right: 15px;
        }
        
        #socket-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .socket-connected {
            background-color: #28a745;
            color: white;
        }
        
        .socket-disconnected {
            background-color: #dc3545;
            color: white;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">Network Self-Healing System</a>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="dashboard-header">
            <h2>System Dashboard</h2>
            <div class="d-flex mt-3">
                <div class="overview-pill">
                    <span id="status-indicator" class="status-badge status-good"></span>
                    <span id="status-text">Network Status: Good</span>
                </div>
                <div class="overview-pill">
                    <strong>Active Issues:</strong> <span id="active-issues-count">0</span>
                </div>
                <div class="overview-pill">
                    <strong>Resolved Issues:</strong> <span id="resolved-issues-count">0</span>
                </div>
                <div class="overview-pill">
                    <strong>Last Updated:</strong> <span id="last-updated">-</span>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Active Issues Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header d-flex justify-content-between align-items-center bg-white">
                        <h5 class="mb-0">Active Issues</h5>
                        <button id="refreshIssues" class="btn btn-sm btn-outline-primary">Refresh</button>
                    </div>
                    <div class="card-body">
                        <div id="issuesList">
                            <!-- Issues will be loaded here -->
                            <div class="alert alert-info">No active issues detected.</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- System Logs Section -->
            <div class="col-md-6">
                <div class="card dashboard-card">
                    <div class="card-header d-flex justify-content-between align-items-center bg-white">
                        <h5 class="mb-0">System Logs</h5>
                        <button id="refreshLogs" class="btn btn-sm btn-outline-primary">Refresh</button>
                    </div>
                    <div class="card-body">
                        <div id="systemLogs" class="event-log">
                            <!-- Logs will be loaded here -->
                            <div class="text-center text-muted py-3">No logs available.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Network Metrics Section -->
        <div class="row">
            <!-- Model Accuracy Card -->
            <div class="col-md-3">
                <div class="card bg-light">
                    <div class="card-body text-center">
                        <h6 class="card-title">Model Accuracy</h6>
                        <div class="d-flex align-items-center justify-content-center">
                            <h3 id="model-accuracy">95.00</h3>
                            <small class="ms-1">%</small>
                        </div>
                        <div class="progress mt-2" style="height: 4px;">
                            <div id="accuracy-bar" class="progress-bar bg-success" role="progressbar" style="width: 95%"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Connected Devices Card -->
            <div class="col-md-3">
                <div class="card bg-light">
                    <div class="card-body text-center">
                        <h6 class="card-title">Connected Devices</h6>
                        <h3 id="network-devices">0</h3>
                        <p id="network-mode" class="badge bg-secondary mt-2">Simulation Mode</p>
                    </div>
                </div>
            </div>
            
            <div class="col-md-3">
                <div class="card bg-light">
                    <div class="card-body text-center">
                        <h6 class="card-title">Latency</h6>
                        <h3 id="network-latency">0 ms</h3>
                        <div class="progress mt-2">
                            <div id="latency-bar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card bg-light">
                    <div class="card-body text-center">
                        <h6 class="card-title">Bandwidth Usage</h6>
                        <h3 id="network-bandwidth">0 Mbps</h3>
                        <div class="progress mt-2">
                            <div id="bandwidth-bar" class="progress-bar bg-info" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row mt-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-body">
                        <h6>Network Status History</h6>
                        <div id="network-history" style="height: 150px;">
                            <div class="text-center text-muted py-5">Network history will appear here...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Connected Clients Section -->
        <div class="row">
            <div class="col-md-12">
                <div class="card dashboard-card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">Connected Clients</h5>
                    </div>
                    <div class="card-body">
                        <div id="connected-clients" class="mt-3">
                            <div class="text-center text-muted py-3">No clients connected...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Resolved Issues Section -->
        <div class="row">
            <div class="col-md-12">
                <div class="card dashboard-card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">Resolved Issues</h5>
                    </div>
                    <div class="card-body">
                        <div id="resolvedIssuesList" class="resolved-issues-list">
                            <!-- Resolved issues will be loaded here -->
                            <div class="text-center text-muted py-3">No resolved issues yet.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Socket.IO connection status indicator -->
    <div id="socket-status" class="socket-disconnected">Disconnected</div>

    <!-- Include Socket.IO client library -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    <script>
        // Generate a unique ID for this browser tab
        const tabId = 'tab_' + Math.random().toString(36).substr(2, 9);
        
        // Initialize Socket.IO connection with improved connection options
        const socket = io({
            transports: ['websocket'],
            forceNew: true,  // Force a new connection for each tab
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });
        
        // Track connected clients
        let connectedClients = 0;

        // Socket status indicator element
        const socketStatus = document.getElementById('socket-status');
        
        // Socket.IO event handlers
        socket.on('connect', function() {
            console.log('Connected to server via Socket.IO');
            socketStatus.className = 'socket-connected';
            socketStatus.textContent = 'Connected';
            
            // Request current client count on connection
            socket.emit('get_client_count');
            
            // Immediately request data updates
            console.log('Requesting initial data after connection');
            // Fetch all data on reconnection
            loadIssues();
            loadResolvedIssues();
            loadSystemLogs();
            checkNetworkStatus();
            
            // Start sending heartbeats
            startHeartbeat();
        });
        
        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = 'Disconnected';
        });
        
        socket.on('connect_error', function(error) {
            console.error('Connection error:', error);
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = 'Connection Error';
        });
        
        socket.on('reconnect_attempt', function(attemptNumber) {
            console.log(`Reconnection attempt #${attemptNumber}`);
            socketStatus.className = 'socket-disconnected';
            socketStatus.textContent = `Reconnecting (#${attemptNumber})`;
        });
        
        socket.on('reconnect', function(attemptNumber) {
            console.log(`Reconnected after ${attemptNumber} attempts`);
            socketStatus.className = 'socket-connected';
            socketStatus.textContent = 'Connected';
            
            // Request fresh data after reconnection
            console.log('Requesting data refresh after reconnection');
            socket.emit('request_data_refresh');
        });
        
        // Handle real-time active issues updates
        socket.on('active_issues_update', function(issues) {
            console.log('Received active issues update:', issues);
            
            const issuesList = document.getElementById('issuesList');
            
            if (!issues || issues.length === 0) {
                issuesList.innerHTML = '<div class="alert alert-info">No active issues detected.</div>';
                updateActiveIssuesCount(0);
                return;
            }
            
            issuesList.innerHTML = '';
            issues.forEach(issue => {
                const issueElement = document.createElement('div');
                issueElement.className = 'alert alert-warning';
                issueElement.innerHTML = `
                    <h5>${issue.title}</h5>
                    <p>${issue.description}</p>
                    <div class="d-flex justify-content-between align-items-center">
                        <span class="badge bg-secondary">${issue.status}</span>
                        <small>Detected: ${formatDate(issue.detected_at)}</small>
                        <button class="btn btn-sm btn-primary resolve-issue" data-id="${issue.id}">
                            Resolve
                        </button>
                    </div>
                `;
                issuesList.appendChild(issueElement);
            });
            
            // Add event listeners to resolve buttons
            document.querySelectorAll('.resolve-issue').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    const issueId = this.getAttribute('data-id');
                    console.log("Resolve button clicked with ID:", issueId);
                    resolveIssue(issueId);
                });
            });
            
            // Update stats
            updateActiveIssuesCount(issues.length);
        });
        
        // Handle real-time resolved issues updates
        socket.on('resolved_issues_update', function(history) {
            console.log('Received resolved issues update:', history);
            
            const resolvedList = document.getElementById('resolvedIssuesList');
            
            if (!history || !Array.isArray(history) || history.length === 0) {
                resolvedList.innerHTML = '<div class="text-center text-muted py-3">No resolved issues yet.</div>';
                updateResolvedIssuesCount(0);
                return;
            }
            
            resolvedList.innerHTML = '';
            
            // Sort by most recent first
            history.sort((a, b) => new Date(b.resolved_at || b.detected_at) - new Date(a.resolved_at || a.detected_at));
            
            // Count real resolved issues
            const resolvedCount = history.filter(item => item.resolution_success).length;
            
            // Keep track of how many we actually displayed
            let displayedCount = 0;
            
            // Display only the most recent 10 issues
            history.slice(0, 10).forEach(item => {
                if (!item.resolved_at) {
                    return; // Skip unresolved items
                }
                
                displayedCount++;
                const issueElement = document.createElement('div');
                issueElement.className = 'resolved-issue';
                
                // Format the actions text
                let actionsText = '';
                if (item.resolution_actions && item.resolution_actions.length > 0) {
                    const lastAction = item.resolution_actions[item.resolution_actions.length - 1];
                    actionsText = `<br><small>Strategy: ${lastAction.strategy}</small>`;
                }
                
                issueElement.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <h6 class="mb-1">${getIssueTitle(item.anomaly_type)}</h6>
                        <span class="badge bg-success">Resolved</span>
                    </div>
                    <p class="mb-1 text-muted">
                        <small>Detected: ${formatDate(item.detected_at)}</small>
                        <br>
                        <small>Resolved: ${formatDate(item.resolved_at)}</small>
                        ${actionsText}
                    </p>
                `;
                resolvedList.appendChild(issueElement);
            });
            
            // If we got no displayable items but there are items in history
            if (displayedCount === 0 && history.length > 0) {
                resolvedList.innerHTML = '<div class="alert alert-warning">Found issues in history but none are fully resolved yet.</div>';
            }
            
            // Update stats
            updateResolvedIssuesCount(resolvedCount);
        });
        
        // Handle real-time logs updates
        socket.on('logs_update', function(logs) {
            console.log('Received logs update');
            
            const logsContainer = document.getElementById('systemLogs');
            
            if (!logs || logs.length === 0) {
                logsContainer.innerHTML = '<div class="text-center text-muted py-3">No logs available.</div>';
                return;
            }
            
            logsContainer.innerHTML = '';
            
            // Sort by most recent first
            logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            logs.forEach(log => {
                const logEntry = document.createElement('div');
                let logClass = 'log-info';
                
                if (log.level === 'WARNING') logClass = 'log-warning';
                if (log.level === 'ERROR') logClass = 'log-error';
                
                logEntry.className = `log-entry ${logClass}`;
                logEntry.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <small>${formatDate(log.timestamp)}</small>
                        <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                    </div>
                    <div class="mt-1">
                        <strong>[${log.source}]</strong> ${log.message}
                    </div>
                `;
                logsContainer.appendChild(logEntry);
            });
        });
        
        // Handle individual log entries
        socket.on('log_entry', function(log) {
            console.log('Received new log entry');
            
            const logsContainer = document.getElementById('systemLogs');
            
            // Remove placeholder if it exists
            if (logsContainer.innerHTML.includes('No logs available')) {
                logsContainer.innerHTML = '';
            }
            
            const logEntry = document.createElement('div');
            let logClass = 'log-info';
            
            if (log.level === 'WARNING') logClass = 'log-warning';
            if (log.level === 'ERROR') logClass = 'log-error';
            
            logEntry.className = `log-entry ${logClass}`;
            logEntry.innerHTML = `
                <div class="d-flex justify-content-between">
                    <small>${formatDate(log.timestamp)}</small>
                    <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                </div>
                <div class="mt-1">
                    <strong>[${log.source}]</strong> ${log.message}
                </div>
            `;
            
            // Add at the beginning (most recent first)
            if (logsContainer.firstChild) {
                logsContainer.insertBefore(logEntry, logsContainer.firstChild);
            } else {
                logsContainer.appendChild(logEntry);
            }
            
            // Limit number of logs displayed
            while (logsContainer.children.length > 50) {
                logsContainer.removeChild(logsContainer.lastChild);
            }
        });
        
        // Handle network status updates
        socket.on('network_status_update', function(status) {
            console.log('Received network status update', status);
            
            // Update dashboard header
            updateDashboardStats(
                document.getElementById('active-issues-count').textContent,
                document.getElementById('resolved-issues-count').textContent,
                status.overall_health
            );
            
            // Update network metrics
            updateNetworkMetrics(status);
        });
        
        // Handle connected clients updates
        socket.on('client_connected', function(data) {
            console.log('Client connected:', data);
            connectedClients = data.count;
            updateConnectedDevices();
        });

        socket.on('client_disconnected', function(data) {
            console.log('Client disconnected:', data);
            connectedClients = data.count;
            updateConnectedDevices();
        });

        socket.on('client_count', function(data) {
            console.log('Client count update:', data);
            connectedClients = data.count;
            updateConnectedDevices();
        });

        function updateConnectedDevices() {
            const devicesElement = document.getElementById('network-devices');
            devicesElement.textContent = connectedClients;
        }
        
        // Initialize date formatter
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleString();
        }
        
        // Update the dashboard header with current stats
        function updateDashboardStats(activeCount, resolvedCount, networkStatus) {
            document.getElementById('active-issues-count').textContent = activeCount;
            document.getElementById('resolved-issues-count').textContent = resolvedCount;
            document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
            
            // Update network status indicator
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            statusIndicator.className = 'status-badge';
            if (networkStatus === 'good') {
                statusIndicator.classList.add('status-good');
                statusText.textContent = 'Network Status: Good';
            } else if (networkStatus === 'warning') {
                statusIndicator.classList.add('status-warning');
                statusText.textContent = 'Network Status: Warning';
            } else {
                statusIndicator.classList.add('status-critical');
                statusText.textContent = 'Network Status: Critical';
            }
        }

        // Load active issues
        function loadIssues() {
            fetch('/api/healing/issues')
                .then(response => response.json())
                .then(issues => {
                    const issuesList = document.getElementById('issuesList');
                    
                    if (issues.length === 0) {
                        issuesList.innerHTML = '<div class="alert alert-info">No active issues detected.</div>';
                        return;
                    }
                    
                    issuesList.innerHTML = '';
                    issues.forEach(issue => {
                        const issueElement = document.createElement('div');
                        issueElement.className = 'alert alert-warning';
                        issueElement.innerHTML = `
                            <h5>${issue.title}</h5>
                            <p>${issue.description}</p>
                            <div class="d-flex justify-content-between align-items-center">
                                <span class="badge bg-secondary">${issue.status}</span>
                                <small>Detected: ${formatDate(issue.detected_at)}</small>
                                <button class="btn btn-sm btn-primary resolve-issue" data-id="${issue.id}">
                                    Resolve
                                </button>
                            </div>
                        `;
                        issuesList.appendChild(issueElement);
                    });
                    
                    // Add event listeners to resolve buttons
                    document.querySelectorAll('.resolve-issue').forEach(button => {
                        // Remove any existing event listeners to prevent duplicates
                        button.replaceWith(button.cloneNode(true));
                        
                        // Get the fresh button
                        const freshButton = issuesList.querySelector(`.resolve-issue[data-id="${button.getAttribute('data-id')}"]`);
                        
                        // Add event listener to the fresh button
                        freshButton.addEventListener('click', function(event) {
                            // Prevent default action
                            event.preventDefault();
                            event.stopPropagation();
                            
                            const issueId = this.getAttribute('data-id');
                            console.log("Resolve button clicked with ID:", issueId);
                            resolveIssue(issueId);
                        });
                    });
                    
                    // Update stats
                    updateActiveIssuesCount(issues.length);
                })
                .catch(error => console.error('Error loading issues:', error));
        }
        
        // Load resolved issues
        function loadResolvedIssues() {
            console.log("Loading resolved issues...");
            fetch('/api/healing/resolved')
                .then(response => {
                    console.log("Resolved issues response:", response.status);
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(history => {
                    console.log("Resolved issues raw data:", JSON.stringify(history).substring(0, 200) + "...");
                    console.log("Resolved issues count:", history ? history.length : 0);
                    
                    const resolvedList = document.getElementById('resolvedIssuesList');
                    
                    if (!history || !Array.isArray(history) || history.length === 0) {
                        resolvedList.innerHTML = '<div class="text-center text-muted py-3">No resolved issues yet.</div>';
                        updateResolvedIssuesCount(0);
                        return;
                    }
                    
                    resolvedList.innerHTML = '';
                    
                    // Sort by most recent first
                    history.sort((a, b) => new Date(b.resolved_at || b.detected_at) - new Date(a.resolved_at || a.detected_at));
                    
                    // Count real resolved issues
                    const resolvedCount = history.filter(item => item.resolution_success).length;
                    console.log(`Displaying ${resolvedCount} resolved issues`);
                    
                    // Keep track of how many we actually displayed
                    let displayedCount = 0;
                    
                    // Display only the most recent 10 issues
                    history.slice(0, 10).forEach(item => {
                        console.log("Processing resolved item:", item);
                        if (!item.resolved_at) {
                            console.log("Skipping unresolved item");
                            return; // Skip unresolved items
                        }
                        
                        displayedCount++;
                        const issueElement = document.createElement('div');
                        issueElement.className = 'resolved-issue';
                        
                        // Format the actions text
                        let actionsText = '';
                        if (item.resolution_actions && item.resolution_actions.length > 0) {
                            const lastAction = item.resolution_actions[item.resolution_actions.length - 1];
                            actionsText = `<br><small>Strategy: ${lastAction.strategy}</small>`;
                        }
                        
                        issueElement.innerHTML = `
                            <div class="d-flex justify-content-between">
                                <h6 class="mb-1">${getIssueTitle(item.anomaly_type)}</h6>
                                <span class="badge bg-success">Resolved</span>
                            </div>
                            <p class="mb-1 text-muted">
                                <small>Detected: ${formatDate(item.detected_at)}</small>
                                <br>
                                <small>Resolved: ${formatDate(item.resolved_at)}</small>
                                ${actionsText}
                            </p>
                        `;
                        resolvedList.appendChild(issueElement);
                    });
                    
                    // If we got no displayable items but there are items in history
                    if (displayedCount === 0 && history.length > 0) {
                        resolvedList.innerHTML = '<div class="alert alert-warning">Found issues in history but none are fully resolved yet.</div>';
                    }
                    
                    // Update stats
                    updateResolvedIssuesCount(resolvedCount);
                })
                .catch(error => {
                    console.error('Error loading resolved issues:', error);
                    document.getElementById('resolvedIssuesList').innerHTML = 
                        '<div class="alert alert-danger">Error loading resolved issues: ' + error.message + '</div>';
                });
        }
        
        // Load system logs
        function loadSystemLogs() {
            fetch('/api/logs')
                .then(response => response.json())
                .then(logs => {
                    const logsContainer = document.getElementById('systemLogs');
                    
                    if (logs.length === 0) {
                        logsContainer.innerHTML = '<div class="text-center text-muted py-3">No logs available.</div>';
                        return;
                    }
                    
                    logsContainer.innerHTML = '';
                    
                    // Sort by most recent first
                    logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    
                    logs.forEach(log => {
                        const logEntry = document.createElement('div');
                        let logClass = 'log-info';
                        
                        if (log.level === 'WARNING') logClass = 'log-warning';
                        if (log.level === 'ERROR') logClass = 'log-error';
                        
                        logEntry.className = `log-entry ${logClass}`;
                        logEntry.innerHTML = `
                            <div class="d-flex justify-content-between">
                                <small>${formatDate(log.timestamp)}</small>
                                <span class="badge ${log.level === 'INFO' ? 'bg-info' : log.level === 'WARNING' ? 'bg-warning' : 'bg-danger'}">${log.level}</span>
                            </div>
                            <div class="mt-1">
                                <strong>[${log.source}]</strong> ${log.message}
                            </div>
                        `;
                        logsContainer.appendChild(logEntry);
                    });
                })
                .catch(error => console.error('Error loading logs:', error));
        }

        // Resolve issue
        function resolveIssue(issueId) {
            console.log("Resolve button clicked for issue:", issueId);
            fetch('/api/healing/resolve', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ issue_id: issueId })
            })
            .then(response => {
                console.log("Resolve response status:", response.status);
                return response.json();
            })
            .then(result => {
                console.log("Resolve result:", result);
                if (result.success) {
                    loadIssues();
                    loadResolvedIssues();
                    loadSystemLogs();
                    alert('Issue resolved successfully!');
                } else {
                    alert('Failed to resolve issue: ' + result.message);
                }
            })
            .catch(error => {
                console.error('Error resolving issue:', error);
                alert('Error resolving issue: ' + error.message);
            });
        }
        
        // Helper functions for stats
        function updateActiveIssuesCount(count) {
            document.getElementById('active-issues-count').textContent = count;
        }
        
        function updateResolvedIssuesCount(count) {
            document.getElementById('resolved-issues-count').textContent = count;
        }
        
        // Helper function to get friendly title for issue types
        function getIssueTitle(anomalyType) {
            const titles = {
                'high_latency': 'High Network Latency',
                'packet_loss': 'Packet Loss Issues',
                'dns_resolution_failure': 'DNS Resolution Failure',
                'routing_loop': 'Network Routing Loop',
                'bandwidth_saturation': 'Bandwidth Saturation',
                'connection_timeout': 'Connection Timeout',
                'security_breach': 'Security Breach',
                'device_failure': 'Device Failure',
                'general_anomaly': 'Network Anomaly'
            };
            return titles[anomalyType] || 'Network Issue';
        }
        
        // Check network status
        function checkNetworkStatus() {
            fetch('/api/network_status')
                .then(response => response.json())
                .then(status => {
                    console.log('Fetched network status:', status);
                    
                    // Update dashboard header
                    updateDashboardStats(
                        document.getElementById('active-issues-count').textContent,
                        document.getElementById('resolved-issues-count').textContent,
                        status.overall_health
                    );
                    
                    // Update network metrics
                    updateNetworkMetrics(status);
                })
                .catch(error => {
                    console.error('Error fetching network status:', error);
                });
        }
        
        // Update network metrics
        function updateNetworkMetrics(status) {
            // Update latency
            document.getElementById('network-latency').textContent = status.latency.toFixed(2) + ' ms';
            document.getElementById('latency-bar').style.width = Math.min(100, (status.latency / 2)) + '%';
            
            // Update bandwidth
            document.getElementById('network-bandwidth').textContent = status.bandwidth_usage.toFixed(2) + ' Mbps';
            document.getElementById('bandwidth-bar').style.width = status.bandwidth_usage + '%';
            
            // Update simulation mode
            const networkMode = document.getElementById('network-mode');
            networkMode.textContent = status.simulation_mode ? 'Simulation Mode' : 'Real Mode';
            networkMode.className = 'badge ' + (status.simulation_mode ? 'bg-secondary' : 'bg-primary') + ' mt-2';
        }
        
        // Simulate model accuracy
        let currentAccuracy = 95.0;
        
        function simulateAccuracy() {
            // Generate random change between -0.3 and 0.3
            const change = (Math.random() - 0.5) * 0.6;
            
            // Update accuracy ensuring it stays between 93 and 97
            currentAccuracy = Math.max(93.0, Math.min(97.0, currentAccuracy + change));
            
            // Update display
            const accuracyElement = document.getElementById('model-accuracy');
            const accuracyBar = document.getElementById('accuracy-bar');
            
            accuracyElement.textContent = currentAccuracy.toFixed(2);
            accuracyBar.style.width = ((currentAccuracy - 90) * 20) + '%';
            
            // Update color based on accuracy level
            if (currentAccuracy >= 96) {
                accuracyBar.className = 'progress-bar bg-success';
            } else if (currentAccuracy >= 94) {
                accuracyBar.className = 'progress-bar bg-info';
            } else {
                accuracyBar.className = 'progress-bar bg-warning';
            }
        }
        
        // Update accuracy every 2 seconds
        setInterval(simulateAccuracy, 2000);
        
        // Initial simulation
        simulateAccuracy();
        
        // Start sending heartbeats
        function startHeartbeat() {
            // Clear any existing interval
            if (window.heartbeatInterval) {
                clearInterval(window.heartbeatInterval);
            }
            
            // Send heartbeat every 30 seconds
            window.heartbeatInterval = setInterval(function() {
                // Get client info (could be extended to allow user to set their name/location)
                const clientInfo = {
                    name: window.clientName || 'Anonymous User',
                    location: 'Unknown Location',
                    tab_id: tabId
                };
                
                socket.emit('client_heartbeat', { client_info: clientInfo });
            }, 30000);
            
            // Send initial heartbeat
            socket.emit('client_heartbeat', { 
                client_info: {
                    name: window.clientName || 'Anonymous User',
                    location: 'Unknown Location',
                    tab_id: tabId
                }
            });
        }
        
        // Setup client identity form
        function setupClientIdentity() {
            // Always prompt for name in each tab
            setTimeout(function() {
                const name = prompt('Enter your name for this session:', '');
                if (name) {
                    // Store name for this tab session only (not in localStorage)
                    window.clientName = name;
                    // Send updated info in heartbeat
                    socket.emit('client_heartbeat', { 
                        client_info: {
                            name: name,
                            location: 'Unknown Location',
                            tab_id: tabId
                        }
                    });
                }
            }, 1000);
        }
        
        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
            loadIssues();
            loadResolvedIssues();
            loadSystemLogs();
            
            // Set up refresh button event listeners
            document.getElementById('refreshIssues').addEventListener('click', loadIssues);
            document.getElementById('refreshLogs').addEventListener('click', loadSystemLogs);
            document.getElementById('refreshMetrics').addEventListener('click', function() {
                console.log('Manually refreshing network metrics');
                checkNetworkStatus();
            });
            
            // Allow user to set their name
            setupClientIdentity();
        });
        
        // Update the connected clients display
        function updateConnectedClients(clients) {
            const clientsContainer = document.getElementById('connected-clients');
            
            if (!clients || clients.length === 0) {
                clientsContainer.innerHTML = '<div class="text-center text-muted py-3">No clients connected...</div>';
                return;
            }
            
            // Sort clients by connection time (newest first)
            clients.sort((a, b) => new Date(b.connected_at) - new Date(a.connected_at));
            
            let html = '<div class="table-responsive"><table class="table table-sm">';
            html += '<thead><tr><th>Client</th><th>IP Address</th><th>Tab ID</th><th>Connected Since</th><th>Status</th></tr></thead>';
            html += '<tbody>';
            
            clients.forEach(client => {
                const name = client.name || 'Anonymous User';
                const connectedAt = formatDate(client.connected_at);
                const status = client.status || 'active';
                const statusClass = status === 'active' ? 'text-success' : 'text-secondary';
                const tabId = client.tab_id || 'unknown';
                
                html += `<tr>
                    <td>${name}</td>
                    <td>${client.ip}</td>
                    <td><small class="text-muted">${tabId}</small></td>
                    <td>${connectedAt}</td>
                    <td><span class="${statusClass}">${status}</span></td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            clientsContainer.innerHTML = html;
            
            // Update the connected devices count
            document.getElementById('network-devices').textContent = clients.length;
        }
        
        // Add a heartbeat to keep connection alive
        setInterval(function() {
            if (socket.connected) {
                console.log('Sending heartbeat ping');
                socket.emit('ping');
            }
        }, 25000);
    </script>
</body>
</html>